# 递归的案例

下面我们通过一个古老而又经典的汉诺塔问题，帮助你理解复杂的递归问题。

汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着 64 片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上，并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

我们可以把这个问题抽象为一个数学问题。如下图所示，从左到右有 x、y、z 三根柱子，其中 x 柱子上面有从小叠到大的 n 个圆盘。现要求将 x 柱子上的圆盘移到 z 柱子上去。要求是，每次只能移动一个盘子，且大盘子不能被放在小盘子上面。求移动的步骤。

![4.png](https://s0.lgstatic.com/i/image/M00/25/AD/CgqCHl7wi--AaoWAAABKD6oIV5c850.png)



我们来分析一下这个问题。这是一个大规模的复杂问题，如果要采用递归方法去解决的话，就要先把问题化简。

我们的原问题是，把从小到大的 n 个盘子，从 x 移动到 z。

我们可以将这个大问题拆解为以下 3 个小问题：

把从小到大的 n-1 个盘子，从 x 移动到 y；

接着把最大的一个盘子，从 x 移动到 z；

再把从小到大的 n-1 个盘子，从 y 移动到 z。

##  F

首先，我们来判断它是否满足递归的第一个条件。 其中，第 1 和第 3 个问题就是汉诺塔问题。这样我们就完成了一次把大问题缩小为完全一样的小规模问题。我们已经定义好了递归体，也就是满足来递归的第一个条件。如下图所示：

![5.gif](https://s0.lgstatic.com/i/image/M00/25/A1/Ciqc1F7wjAuAJ7yrAAzAObiXQfs227.gif)



## S

接下来我们来看判断它是否满足终止条件。随着递归体不断缩小范围，汉诺塔问题由原来“移动从小到大的 n 个盘子”，缩小为“移动从小到大的 n-1 个盘子”，直到缩小为“移动从小到大的 1 个盘子”。移动从小到大的 1 个盘子，就是移动最小的那个盘子。根据规则可以发现，最小的盘子是可以自由移动的。因此，递归的第二个条件，终止条件，也是满足的。

经过仔细分析可见，汉诺塔问题是完全可以用递归实现的。我们定义汉诺塔的递归函数为 hanio()。这个函数的输入参数包括了：

3 根柱子的标记 x、y、z；

待移动的盘子数量 n。

具体代码如下所示，在代码中，hanio(n, x, y, z)，代表了把 n 个盘子由 x 移动到 z。根据分析，我们知道递归体包含 3 个步骤：

把从小到大的 n-1 个盘子从 x 移动到 y，那么代码就是 hanio(n-1, x, z, y)；

再把最大的一个盘子从 x 移动到 z，那么直接完成一次移动的动作就可以了；

再把从小到大的 n-1 个盘子从 y 移动到 z，那么代码就是 hanio(n-1, y, x, z)。对于终止条件则需要判断 n 的大小。如果 n 等于 1，那么同样直接移动就可以了。

## T

```
public static void main(String[] args) {
    String x = "x";
    String y = "y";
    String z = "z";
    hanio(3, x, y, z);
}
public void hanio(int n, String x, String y, String z) {
    if (n < 1) {
        System.out.println("汉诺塔的层数不能小于1");
    } else if (n == 1) {
        System.out.println("移动: " + x + " -> " + z);
        return;
    } else {
        hanio(n - 1, x, z, y);
        System.out.println("移动: " + x + " -> " + z);
        hanio(n - 1, y, x, z);
    }
}
```

我们以 n = 3 为例，执行一下这段代码：

我们以 n = 3 为例，执行一下这段代码：

在主函数中，执行了 hanio(3, "x", "y", "z")。我们发现 3 比 1 要大，则进入递归体。分别先后执行了 hanio(2, "x", "z", "y")、"移动: x->z"、hanio(2, "y", "x", "z")。

其中的 hanio(2, "x", "z", "y")，又先后执行了 hanio(1, "x", "y", "z")、"移动: x->y"、hanio(1, "z", "x", "y")。在这里，hanio(1, "x", "y", "z") 的执行结果是 "移动: x->z"，hanio(1, "z", "x", "y")的执行结果是"移动: z->y"。

另一边，hanio(2, "y", "x", "z") 则要先后执行 hanio(1, "y", "z", "x")、"移动: y->z"、hanio(1, "x", "y", "z")。在这里，hanio(1, "y", "z", "x") 的执行结果是"移动: y->x"，hanio(1, "x", "y", "z") 的执行结果是 "移动: x->z"。

![6.gif](https://s0.lgstatic.com/i/image/M00/25/A2/Ciqc1F7wjD6AHleLAAmzm2nvvmw746.gif)

## L

最终梳理一下，代码执行的结果就是：

移动: x->z

移动: x->y

移动: z->y

移动: x->z

移动: y->x

移动: y->z

移动: x->z

抛开用于处理输入异常的代码部分不谈，它的代码包含了 2 个部分：

终止条件，即如何处理小规模的问题，实现的代码量一定是很少的；

递归体，即大问题向小问题分解的过程，实现的代码量也不会太多。

因此，一个复杂问题的递归实现，通常代码量都不会很多。



# 总结

递归的核心思想是把规模大的问题转化为规模小的相似的子问题来解决。

在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况。另外这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况了。递归的应用非常广泛，之后我们要讲的很多数据结构和算法的编码实现都要用到递归，例如分治策略、快速排序等等。