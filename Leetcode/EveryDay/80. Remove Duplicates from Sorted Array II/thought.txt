对于此类问题，我们应该进行如下考虑：  // For recursion

由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留

对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留
举个🌰，我们令 k=2，假设有如下样例

[1,1,1,1,1,1,2,2,2,2,2,2,3]

首先我们先让前 2 位直接保留，得到 1,1

对后面的每一位进行继续遍历，能够保留的前提是与当前位置的前面 k 个元素不同（答案中的第一个 1），因此我们会跳过剩余的 1，将第一个 2 追加，得到 1,1,2

继续这个过程，这时候是和答案中的第 2 个 1 进行对比，因此可以得到 1,1,2,2

这时候和答案中的第 1 个 2 比较，只有与其不同的元素能追加到答案，因此剩余的 2 被跳过，3 被追加到答案：1,1,2,2,3

------------------------------------------------------------------------------------------ For iteration
注意是原地修改，那么肯定就需要一个指针指向当前即将放置元素的位置，需要另外一个指针向后遍历所有元素，所以「双指针」解法就呼之欲出了。如果能想到双指针解法，后面的分析也就顺理成章。

慢指针 slow : 指向当前即将放置元素的位置；则 slow - 1 是刚才已经放置了元素的位置。
快指针 fast : 向后遍历所有元素；
因为最多允许两个重复元素，并且 slow - 2 位置是上上次放置了元素的位置，所以让 nums[fast] 跟 nums[slow - 2] 进行比较。每次都是只允许最多两个元素出现重复，这两个元素的位置在 slow - 1 和 slow - 2.
